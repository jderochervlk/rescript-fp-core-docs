// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as LoadScript from "../ffi/loadScript";
import LoadScript$1 from "../ffi/loadScript";
import * as RescriptCompilerApi from "../bindings/RescriptCompilerApi.mjs";

function loadScriptPromise(url) {
  return new Promise((function (resolve, _reject) {
                LoadScript$1(url, (function (param) {
                        resolve({
                              TAG: 0,
                              _0: undefined,
                              [Symbol.for("name")]: "Ok"
                            });
                      }), (function (_err) {
                        resolve({
                              TAG: 1,
                              _0: "Could not load script: " + url,
                              [Symbol.for("name")]: "Error"
                            });
                      }));
              }));
}

var versions = [
  "v10.1.2",
  "v10.0.1",
  "v10.0.0",
  "v9.1.2",
  "v9.0.2",
  "v9.0.1",
  "v9.0.0",
  "v8.4.2",
  "v8.3.0-dev.2"
];

var experimentalVersions = [
  "v11.0.0-beta.4",
  "v11.0.0-beta.1",
  "v11.0.0-alpha.5"
];

function getCompilerUrl(version) {
  return "https://cdn.rescript-lang.org/" + version + "/compiler.js";
}

function getLibraryCmijUrl(version, libraryName) {
  return "https://cdn.rescript-lang.org/" + version + "/" + libraryName + "/cmij.js";
}

var CdnMeta = {
  versions: versions,
  experimentalVersions: experimentalVersions,
  getCompilerUrl: getCompilerUrl,
  getLibraryCmijUrl: getLibraryCmijUrl
};

var FinalResult = {};

function getLibrariesForVersion(version) {
  var match = Belt_List.fromArray(version.split("."));
  if (!match) {
    return [];
  }
  var version$1 = Belt_Option.getWithDefault(Belt_Int.fromString(match.hd.replace("v", "")), 0);
  var libraries = version$1 >= 9 ? ["@rescript/react"] : (
      version$1 < 9 ? ["reason-react"] : []
    );
  if (version$1 >= 11) {
    libraries.push("@rescript/core");
    libraries.push("compiler-builtins");
  }
  return libraries;
}

async function attachCompilerAndLibraries(version, libraries, param) {
  var compilerUrl = getCompilerUrl(version);
  var match = await loadScriptPromise(compilerUrl);
  if (match.TAG !== /* Ok */0) {
    return {
            TAG: 1,
            _0: ["Could not load compiler from url " + compilerUrl + ""],
            [Symbol.for("name")]: "Error"
          };
  }
  var promises = Belt_Array.map(libraries, (async function (lib) {
          var cmijUrl = getLibraryCmijUrl(version, lib);
          var r = await loadScriptPromise(cmijUrl);
          if (r.TAG === /* Ok */0) {
            return r;
          } else {
            return {
                    TAG: 1,
                    _0: "Could not load cmij from url " + cmijUrl + "",
                    [Symbol.for("name")]: "Error"
                  };
          }
        }));
  var all = await Promise.all(promises);
  var errors = Belt_Array.keepMap(all, (function (r) {
          if (r.TAG === /* Ok */0) {
            return ;
          } else {
            return r._0;
          }
        }));
  if (errors.length !== 0) {
    return {
            TAG: 1,
            _0: errors,
            [Symbol.for("name")]: "Error"
          };
  } else {
    return {
            TAG: 0,
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  }
}

function useCompilerManager(initialVersion, initialLangOpt, onAction, param) {
  var initialLang = initialLangOpt !== undefined ? initialLangOpt : /* Res */2;
  var match = React.useState(function () {
        return /* Init */0;
      });
  var setState = match[1];
  var state = match[0];
  var dispatch = function (action) {
    Belt_Option.forEach(onAction, (function (cb) {
            Curry._1(cb, action);
          }));
    switch (action.TAG | 0) {
      case /* SwitchToCompiler */0 :
          var id = action._0;
          if (typeof state === "number") {
            return ;
          }
          if (state.TAG !== /* Ready */2) {
            return ;
          }
          var ready = state._0;
          if (ready.selected.id !== id) {
            return Curry._1(setState, (function (param) {
                          return {
                                  TAG: 1,
                                  _0: ready,
                                  _1: id,
                                  [Symbol.for("name")]: "SwitchingCompiler"
                                };
                        }));
          } else {
            return ;
          }
      case /* SwitchLanguage */1 :
          var code = action.code;
          var lang = action.lang;
          if (typeof state === "number") {
            return ;
          }
          if (state.TAG !== /* Ready */2) {
            return ;
          }
          var ready$1 = state._0;
          var instance = ready$1.selected.instance;
          var availableTargetLangs = RescriptCompilerApi.Version.availableLanguages(ready$1.selected.apiVersion);
          var currentLang = ready$1.targetLang;
          return Belt_Option.forEach(Caml_option.undefined_to_opt(availableTargetLangs.find(function (l) {
                              return l === lang;
                            })), (function (lang) {
                        var match = ready$1.selected.apiVersion;
                        var match$1;
                        if (match === 0) {
                          var convResult;
                          switch (currentLang) {
                            case /* Reason */0 :
                                convResult = lang >= 2 ? RescriptCompilerApi.Compiler.convertSyntax(/* Reason */0, /* Res */2, code, instance) : undefined;
                                break;
                            case /* OCaml */1 :
                                convResult = undefined;
                                break;
                            case /* Res */2 :
                                convResult = lang !== 0 ? undefined : RescriptCompilerApi.Compiler.convertSyntax(/* Res */2, /* Reason */0, code, instance);
                                break;
                            
                          }
                          if (convResult !== undefined) {
                            if (convResult.TAG === /* Success */0) {
                              match$1 = [
                                {
                                  TAG: 0,
                                  _0: convResult,
                                  [Symbol.for("name")]: "Conv"
                                },
                                lang
                              ];
                            } else {
                              var secondTry = RescriptCompilerApi.Compiler.convertSyntax(lang, lang, code, instance);
                              match$1 = [
                                {
                                  TAG: 0,
                                  _0: secondTry,
                                  [Symbol.for("name")]: "Conv"
                                },
                                lang
                              ];
                            }
                          } else {
                            match$1 = [
                              /* Nothing */0,
                              lang
                            ];
                          }
                        } else {
                          match$1 = [
                            /* Nothing */0,
                            lang
                          ];
                        }
                        var targetLang = match$1[1];
                        var result = match$1[0];
                        Curry._1(setState, (function (param) {
                                return {
                                        TAG: 2,
                                        _0: {
                                          versions: ready$1.versions,
                                          experimentalVersions: ready$1.experimentalVersions,
                                          selected: ready$1.selected,
                                          targetLang: targetLang,
                                          errors: [],
                                          result: result
                                        },
                                        [Symbol.for("name")]: "Ready"
                                      };
                              }));
                      }));
      case /* Format */2 :
          var code$1 = action._0;
          if (typeof state === "number") {
            return ;
          }
          if (state.TAG !== /* Ready */2) {
            return ;
          }
          var ready$2 = state._0;
          var instance$1 = ready$2.selected.instance;
          var match = ready$2.targetLang;
          var convResult;
          switch (match) {
            case /* Reason */0 :
                convResult = RescriptCompilerApi.Compiler.reasonFormat(instance$1, code$1);
                break;
            case /* OCaml */1 :
                convResult = undefined;
                break;
            case /* Res */2 :
                convResult = RescriptCompilerApi.Compiler.resFormat(instance$1, code$1);
                break;
            
          }
          var result = convResult !== undefined && !(convResult.TAG === /* Success */0 && code$1 === convResult._0.code) ? ({
                TAG: 0,
                _0: convResult,
                [Symbol.for("name")]: "Conv"
              }) : ready$2.result;
          return Curry._1(setState, (function (param) {
                        return {
                                TAG: 2,
                                _0: {
                                  versions: ready$2.versions,
                                  experimentalVersions: ready$2.experimentalVersions,
                                  selected: ready$2.selected,
                                  targetLang: ready$2.targetLang,
                                  errors: [],
                                  result: result
                                },
                                [Symbol.for("name")]: "Ready"
                              };
                      }));
      case /* CompileCode */3 :
          var code$2 = action._1;
          var lang$1 = action._0;
          if (typeof state === "number") {
            return ;
          }
          if (state.TAG !== /* Ready */2) {
            return ;
          }
          var ready$3 = state._0;
          return Curry._1(setState, (function (param) {
                        return {
                                TAG: 3,
                                _0: ready$3,
                                _1: [
                                  lang$1,
                                  code$2
                                ],
                                [Symbol.for("name")]: "Compiling"
                              };
                      }));
      case /* UpdateConfig */4 :
          var config = action._0;
          if (typeof state === "number") {
            return ;
          }
          if (state.TAG !== /* Ready */2) {
            return ;
          }
          var ready$4 = state._0;
          RescriptCompilerApi.Compiler.setConfig(ready$4.selected.instance, config);
          return Curry._1(setState, (function (param) {
                        var init = ready$4.selected;
                        var selected_id = init.id;
                        var selected_apiVersion = init.apiVersion;
                        var selected_compilerVersion = init.compilerVersion;
                        var selected_ocamlVersion = init.ocamlVersion;
                        var selected_libraries = init.libraries;
                        var selected_instance = init.instance;
                        var selected = {
                          id: selected_id,
                          apiVersion: selected_apiVersion,
                          compilerVersion: selected_compilerVersion,
                          ocamlVersion: selected_ocamlVersion,
                          libraries: selected_libraries,
                          config: config,
                          instance: selected_instance
                        };
                        return {
                                TAG: 2,
                                _0: {
                                  versions: ready$4.versions,
                                  experimentalVersions: ready$4.experimentalVersions,
                                  selected: selected,
                                  targetLang: ready$4.targetLang,
                                  errors: ready$4.errors,
                                  result: ready$4.result
                                },
                                [Symbol.for("name")]: "Ready"
                              };
                      }));
      
    }
  };
  var dispatchError = function (err) {
    Curry._1(setState, (function (prev) {
            var msg = err._0;
            if (typeof prev === "number") {
              return {
                      TAG: 0,
                      _0: msg,
                      [Symbol.for("name")]: "SetupFailed"
                    };
            }
            if (prev.TAG !== /* Ready */2) {
              return {
                      TAG: 0,
                      _0: msg,
                      [Symbol.for("name")]: "SetupFailed"
                    };
            }
            var ready = prev._0;
            return {
                    TAG: 2,
                    _0: {
                      versions: ready.versions,
                      experimentalVersions: ready.experimentalVersions,
                      selected: ready.selected,
                      targetLang: ready.targetLang,
                      errors: ready.errors.concat([msg]),
                      result: ready.result
                    },
                    [Symbol.for("name")]: "Ready"
                  };
          }));
  };
  React.useEffect((function () {
          var updateState = async function (param) {
            if (typeof state === "number") {
              if (versions.length === 0) {
                return dispatchError({
                            TAG: 0,
                            _0: "No compiler versions found",
                            [Symbol.for("name")]: "SetupError"
                          });
              }
              var latest = Caml_array.get(versions, 0);
              var initVersion;
              if (initialVersion !== undefined) {
                var allVersions = Belt_Array.concat(versions, experimentalVersions);
                initVersion = allVersions.some(function (v) {
                      return initialVersion === v;
                    }) ? initialVersion : latest;
              } else {
                initVersion = latest;
              }
              var libraries = getLibrariesForVersion(initVersion);
              var errs = await attachCompilerAndLibraries(initVersion, libraries, undefined);
              if (errs.TAG === /* Ok */0) {
                var instance = rescript_compiler.make();
                var apiVersion = RescriptCompilerApi.Version.fromString(rescript_compiler.api_version);
                var newrecord = Caml_obj.obj_dup(RescriptCompilerApi.Compiler.getConfig(instance));
                newrecord.module_system = "es6";
                RescriptCompilerApi.Compiler.setConfig(instance, newrecord);
                var selected_compilerVersion = RescriptCompilerApi.Compiler.version(instance);
                var selected_ocamlVersion = RescriptCompilerApi.Compiler.ocamlVersion(instance);
                var selected = {
                  id: initVersion,
                  apiVersion: apiVersion,
                  compilerVersion: selected_compilerVersion,
                  ocamlVersion: selected_ocamlVersion,
                  libraries: libraries,
                  config: newrecord,
                  instance: instance
                };
                var targetLang = Belt_Option.getWithDefault(Caml_option.undefined_to_opt(RescriptCompilerApi.Version.availableLanguages(apiVersion).find(function (l) {
                              return l === initialLang;
                            })), RescriptCompilerApi.Version.defaultTargetLang);
                return Curry._1(setState, (function (param) {
                              return {
                                      TAG: 2,
                                      _0: {
                                        versions: versions,
                                        experimentalVersions: experimentalVersions,
                                        selected: selected,
                                        targetLang: targetLang,
                                        errors: [],
                                        result: /* Nothing */0
                                      },
                                      [Symbol.for("name")]: "Ready"
                                    };
                            }));
              }
              var msg = errs._0.join("; ");
              return dispatchError({
                          TAG: 1,
                          _0: msg,
                          [Symbol.for("name")]: "CompilerLoadingError"
                        });
            }
            switch (state.TAG | 0) {
              case /* SwitchingCompiler */1 :
                  var version = state._1;
                  var ready = state._0;
                  var libraries$1 = getLibrariesForVersion(version);
                  var errs$1 = await attachCompilerAndLibraries(version, libraries$1, undefined);
                  if (errs$1.TAG === /* Ok */0) {
                    var prim = getCompilerUrl(ready.selected.id);
                    LoadScript.removeScript(prim);
                    Belt_Array.forEach(ready.selected.libraries, (function (lib) {
                            var prim = getLibraryCmijUrl(ready.selected.id, lib);
                            LoadScript.removeScript(prim);
                          }));
                    var instance$1 = rescript_compiler.make();
                    var apiVersion$1 = RescriptCompilerApi.Version.fromString(rescript_compiler.api_version);
                    var config = RescriptCompilerApi.Compiler.getConfig(instance$1);
                    var selected_compilerVersion$1 = RescriptCompilerApi.Compiler.version(instance$1);
                    var selected_ocamlVersion$1 = RescriptCompilerApi.Compiler.ocamlVersion(instance$1);
                    var selected$1 = {
                      id: version,
                      apiVersion: apiVersion$1,
                      compilerVersion: selected_compilerVersion$1,
                      ocamlVersion: selected_ocamlVersion$1,
                      libraries: libraries$1,
                      config: config,
                      instance: instance$1
                    };
                    return Curry._1(setState, (function (param) {
                                  return {
                                          TAG: 2,
                                          _0: {
                                            versions: ready.versions,
                                            experimentalVersions: ready.experimentalVersions,
                                            selected: selected$1,
                                            targetLang: RescriptCompilerApi.Version.defaultTargetLang,
                                            errors: [],
                                            result: /* Nothing */0
                                          },
                                          [Symbol.for("name")]: "Ready"
                                        };
                                }));
                  }
                  var msg$1 = errs$1._0.join("; ");
                  return dispatchError({
                              TAG: 1,
                              _0: msg$1,
                              [Symbol.for("name")]: "CompilerLoadingError"
                            });
              case /* SetupFailed */0 :
              case /* Ready */2 :
                  return ;
              case /* Compiling */3 :
                  var match = state._1;
                  var code = match[1];
                  var lang = match[0];
                  var ready$1 = state._0;
                  var apiVersion$2 = ready$1.selected.apiVersion;
                  var instance$2 = ready$1.selected.instance;
                  var compResult;
                  if (typeof apiVersion$2 === "number") {
                    if (apiVersion$2 !== 0) {
                      switch (lang) {
                        case /* Reason */0 :
                            compResult = {
                              TAG: 2,
                              _0: "Reason not supported with API version \"" + RescriptCompilerApi.Version.toString(apiVersion$2) + "\"",
                              [Symbol.for("name")]: "UnexpectedError"
                            };
                            break;
                        case /* OCaml */1 :
                            compResult = RescriptCompilerApi.Compiler.ocamlCompile(instance$2, code);
                            break;
                        case /* Res */2 :
                            compResult = RescriptCompilerApi.Compiler.resCompile(instance$2, code);
                            break;
                        
                      }
                    } else {
                      switch (lang) {
                        case /* Reason */0 :
                            compResult = RescriptCompilerApi.Compiler.reasonCompile(instance$2, code);
                            break;
                        case /* OCaml */1 :
                            compResult = RescriptCompilerApi.Compiler.ocamlCompile(instance$2, code);
                            break;
                        case /* Res */2 :
                            compResult = RescriptCompilerApi.Compiler.resCompile(instance$2, code);
                            break;
                        
                      }
                    }
                  } else {
                    compResult = {
                      TAG: 2,
                      _0: "Can't handle result of compiler API version \"" + apiVersion$2._0 + "\"",
                      [Symbol.for("name")]: "UnexpectedError"
                    };
                  }
                  return Curry._1(setState, (function (param) {
                                return {
                                        TAG: 2,
                                        _0: {
                                          versions: ready$1.versions,
                                          experimentalVersions: ready$1.experimentalVersions,
                                          selected: ready$1.selected,
                                          targetLang: ready$1.targetLang,
                                          errors: ready$1.errors,
                                          result: {
                                            TAG: 1,
                                            _0: compResult,
                                            [Symbol.for("name")]: "Comp"
                                          }
                                        },
                                        [Symbol.for("name")]: "Ready"
                                      };
                              }));
              
            }
          };
          updateState(undefined);
        }), [state]);
  return [
          state,
          dispatch
        ];
}

export {
  FinalResult ,
  CdnMeta ,
  useCompilerManager ,
}
/* react Not a pure module */
